%!TEX root = ../dokumentation.tex

\chapter{Implementierung der Spielstrategie}
\section{Erweiterung des Bilderkennungsprogramms um Kommunikationsmodul}
Die Kommunikation zwischen PC und Roboter erfolgt wie in Kapitel \ref{cha:Kommunikation zwischen Bilderkennung und Roboter} auf Seite \pageref{cha:Kommunikation zwischen Bilderkennung und Roboter} mithilfe von Sockets. Der PC öffnet einen Serversocket und der Roboter einen Clientsocket. Die Socketkommunikation funktioniert nach dem TCP/IP Verfahren. Man weiß also immer ob die Kommunikation zu Stande kam.
Ursprünglich hatten wir für jede Übertragung einen neuen Socket erstellt, die Daten übermittelt und anschließend den Socket wieder geschlossen. Dies haben wir so praktiziert da in der Python Dokumentation geschrieben stand, das Sockets normalerweise nur für eine Übertratung oder eine kleine Folge von Übertragungen genutzt wird und anschließend wieder geschlossen wird.
\begin{quote}
When the connect completes, the socket s can be used to send in a request for the text of the page. The same socket will read the reply, and then be destroyed. That’s right, destroyed. Client sockets are normally only used for one exchange (or a small set of sequential exchanges).\cite{Python-Doku}
\end{quote}
Da auch der Socket auf der Serverseite freigegeben werden musste, konnte bei einem erneuten Kommunikationsversuches des Clients keine Verbindung zum Serversocket des Roboters hergestellt werden. Dadurch wussten wir auch automatisch, dass der Roboter sich noch bewegt und keine neuen Befehle entgegen nehmen kann. Wir hatten für die Sockets eine timeoutzeit von $\frac{1}{100}$s eingestellt. Somit hat ein Kommunikationsversuch mit dem Roboter maximal 1/50s benötigt. Einmal  1/100s für die Verbindung aufbauen und einmal 1/100s für die Daten senden. Da wir mit der angebauten 30 FPS Kamera nur alle 1/30s neue Bilder erhielten mit denen man neu rechnen muss, war diese 1/50s Maximalzeit auch ausreichend. Es hat sich aber herausgestellt, das anscheinend durch das Socket öffnen und schließen eine viel größere Zeit benötigt wird. Denn zwischen dem senden eines Befehls und dem erneuten senden eines Befehls vergingen mindestens eine halbe Sekunde, selbst wenn sich der Roboter gar nicht bewegen muss. Hinzu kam noch, dass das Schließen des Sockets auf Serverseite länger benötigt als auf Clientseite. Die Zeit die zum Schließen des Serversockets benötigt wurde, hat wahrscheinlich auch diese halbe Sekunde Latenzzeit verursacht. Es entstand aber auch noch ein anderer Nebeneffekt dadurch. Denn der Clientsocket hat in dieser Zeit immer noch eine Verbindung mit dem Serversocket erstellen können und hat somit auch noch Daten geschickt. Diese Daten kamen aber nicht mehr beim Serversocket an, sondern wurden irgendwo zwischen gebuffert. Beim nächsten öffnen des Serversockets wurden dann diese Daten sofort empfangen und verarbeitet. Durch diesen Buffer entstanden immer Ausreißer des Roboters, die wir uns lange Zeit nicht erklären konnten. Wir haben dieses Problem dann erst mitbekommen, nachdem wir ein paar Tests durchgeführt haben um die Geschwindigkeit des Roboters festzustellen. Das Programm für die Test hat dann häufig bis zu 3 Werte hintereinander geschickt, bevor es gewartet hat, das der Roboter einen neuen Serversocket geöffnet hat. Wir führten darauf hin einen Two-Way-Handshake ein. Ursprünglich hatten wir dann solange gewartet bis der Roboter sein OK geschickt hat. Dabei hatten wir nur ein nicht beachtet und zwar dass das Programm sequentiell abläuft und für die Wartezeit wie eingefroren ist. Das heißt wir haben dann auch nur alle halbe Sekunde das neue Bild von der Kamera ausgewertet. Dadurch konnte das ganze Programm nicht mehr ordentlich reagieren, da keine vernünftigen Puckbewegungen mehr errechnet werden konnten. Beim zweiten Versuch, wurde pro Programmzyklus nur einmal überprüft ob der Roboter sein OK gesendet hat. Wenn dieses OK nicht kam wurde auf das neue Bild gewartet und dann erneut abgefragt bis der Roboter sein OK gesendet hat. Dadurch konnten wir zwar die Aussreißer stark reduzieren, aber es gab immer noch die hohe Latenzzeit von mindestens einer halben Sekunde. Am Ende haben wir uns dann gegen die Empfehlung der Python Dokumentation entschieden und nur am Amfang des Programmstartes einen Socket zu öffnen und diesen über die komplette Programmlaufzeit offen zu lassen. Wir konnten auch bei längeren Laufzeiten von einer halben Stunde und mehr keine Irregularitäten feststellen, weshalb wir entschieden haben, dies dann so zu lassen. Der einzige Nachteil war, dass wir die Sockets auf diese Art und Weise nicht ordentlich schließen konnten, denn es gibt in Python keinen Deconstructor, wie man ihn aus anderen Objektorientierten Programmiersprachen kennt. Deshalb muss man nach Abbruch des Programms 1-2 Minuten warten bis das Betriebssystem den Socket von alleine wieder schließt. Leider kann man ohne eine Referenz auf den Socket diesen nicht manuell schließen. Und da wir nicht jedesmal den Programmcode umschreiben wollten um einen neuen Port einzutragen, mussten wir zwischen den Tests immer ein weilchen warten.
%Die Kommunikation zwischen PC und Roboter erfolgt mithilfe von Sockets. Der Roboter öffnet dafür einen Serversocket und horcht auf einen bestimmten Port. Der PC erzeugt einen Clientsocket und verbindet sich mit der IP-Adresse des Roboters und dem gewählten Port. Die Socketkommunikation funktioniert nach dem TCP/IP Verfahren. Man weiß also immer ob die Kommunikation zu Stande kam. Nachdem die Kommunikation zu stande kam werden die Daten nach dem UDP-Verfahren gesendet ohne zu überprüfen ob der Roboter die Daten erhalten hat. Ursprünglich hatten wir eine Art Two-Way-Handshake implementiert, so das der Roboter nach dem Erhalt der Daten eine kurze Rückmeldung sendete. Dies hat aber zu lange gedauert wodurch das komplette Programm gelaggt hat.

\section{Implementierung von Spielstrategien}
\subsection{Defensive Spielstrategie}
Bei der Defensiven Spielstrategie wird der Schläger nur auf einer geraden Linie parallel zum Tor bewegt. Bei dieser Strategie kann man grundsätzlich von 2 Situationen ausgehen. Die erste ist, der Puck bewegt sich auf den Roboter zu. Der Roboter versucht den Puck abzuwehren, erstmal ungeachtet ob der Puck sich überhaupt aufs Tor zu bewegt oder daran vorbeigehen würde. Bei der zweiten Situation bewegt sich der Puck vom Roboter weg. Dabei sollte sich der Puck zwischen dem Tor des Roboters und dem Puck positionieren und dem nächsten Angriff des Spielers zuvorzukommen.

Bei einer erweiterten Defensivstrategie könnte z.B. zusätzlich überprüft werden ob der Puck überhaupt das Tor trifft oder in die Nähe des Tores kommt um unnötige Bewegungen zu vermeiden.

\subsection{offensive Spielstrategie}
Bei der Offensiven Strategie versucht der Roboter immer den Puck sofort zurückzuschlagen ohne an eine Verteidigung zu denken, frei nach dem Motto “Angriff ist die beste Verteidigung”. Dabei sollte angefangen werden den Puck nur zurückzuschlagen ungeachtet der Richtung. Sollte diese Taktik funktionieren, kann man dann ergänzen, dem Puck beim zurückschlagen eine bestimme Richtung zu geben, damit der Roboter gezielter das gegnerische Tor trifft.

Später kann diese Strategie so erweitert werden, dass sich der Roboter nicht direkt auf den Puck zu bewegt, sondern sich vorher noch positioniert um eine bessere Angriffsposition zu haben.
\subsection{Defensive Spielstrategie mit offensiven Ansätzen}
Es wird weiterhin die selbe Taktik wie bei der rein defensiven Taktik genutzt. Zusätzlich wird ergänzt, das nach dem Blocken des Puckes, dieser mit der offensiven Strategie zurückgeschlagen wird.

\subsection{ausbalancierte Spielstrategie}
Bei der ausbalancierten Spielstrategie wird selbstständig vom Roboter entschieden, ob die Defensive oder die offensive Strategie verwendet wird. Bei der defensiven Strategie sollte die Verteidigungslinie auf einen Bereich unmittelbar vor dem Tor reduziert werden um unnötige Verteidigungsaktionen zu vermeiden.



\section{Strategieimplementierung und -entscheidung}
Bei unserer Spielstrategie wird eine ausbalancierte Strategie verwendet. Um diese Strategie ausführen zu können, wurden vier unterschiedliche Befehle eingeführt. Diese kann man grundsätziche in 2 Kategorien unterteilen, in defensive und iffensive Befehle. Bei vieler dieser Funktionen und auch der Entscheidung wird eine Funktion zur Schnittpunktberechnung benutzt, deshalb wird diese jetzt gleich vorab erklärt wie diese funktioniert. Die Funktion für die Schnittpunktberechnung ist  in \ref{lst:Schnittpunktberechnung} auf Seite \pageref{lst:Schnittpunktberechnung} zu sehen. Hier wird nur die Schnittpunkberechnung für eine X"~Achse erläutert. Dieselbe Methode kann aber leicht umgeändert auch für Schnittpunkte mit einer Y"~Achse verwendet werden.

\begin{lstlisting}[caption= Python-Funktion für Schnittpunktberechnung, label=lst:Schnittpunktberechnung]
def CrossXLine(self,bag, xLine, startposition = None, direction = None):     
	if startposition == None:
		startposition = bag.puck.position
	if direction == None:
		direction = bag.puck.direction
	if direction[0] == 0:
		return None
	timeToCrossXLine = (xLine - startposition[0])/(direction[0] * bag.puck.velocity)
	yPosition = startposition[1] + timeToCrossXLine * direction[1] * bag.puck.velocity
	
	#Wenn der Puck ausserhalb der Spielfeldbegrenzung liegt, wird dieser vor dem zurueckgeben noch an der Spielfeldgranze gespiegelt
	koordinates = vector.mirror_point_into_field([xLine, yPosition])
	return (koordinates[0], koordinates[1], timeToCrossXLine)
\end{lstlisting}


\begin{wrapfigure}{R}{0pt}
\vspace{-15pt}
\includegraphics{Schnittpunktberechnung.png}
\vspace{-15pt}
\caption{Veranschaulichung der Schnittpunktberechnung}
\vspace{-15pt}
\label{img:Schnittpunktberechnung}
\end{wrapfigure}

Man kann mithilfe eines Punktes und eines Bewegungsvektors kann eine Gerade dargestellt werden. Die Geradengleichung im 2-Dimensionalen Raum sieht in dann so aus: \\
$\left(\begin{array}{c} x \\ y \end{array}\right) = \left(\begin{array}{c} x_P \\ y_P \end{array}\right) + k * \left(\begin{array}{c} x_R \\ y_R \end{array}\right)$. \\
X und Y sind dabei die Koordinaten jeden beliebigen Punktes auf der Geraden. $X_P$ und $Y_P$ sind die Koordinaten eines belibigen Punktes auf dieser Geraden. In unserem Fall ist dies die Position des Puckes. $X_R$ und $Y_R$ sind Teile des Richtungsvektors. Der Scalar k ist eine reelle Zahl udn streckt oder staucht den Richtungsvektor um jeden belibigen Punkt auf der Geraden zu erreichen. Im Bild \ref{img:Schnittpunktberechnung} auf Seite \pageref{img:Schnittpunktberechnung} ist dies nochmal grafisch dargestellt worden. Wir haben die Position des Puckes und die Bewegungsrichtung des Puckes. Wenn wir nun den Bewegungsvektor des Puckes entsprechend strecken oder stauchen, schneiden wir die gewünschte X"~Achse. Wir könnten nun für die gewünschte X"~Achse auch eine Geradengleichung aufstellen und dann die beiden Gleichungen in einem Gleichungssystem gleichsetzen, aber da wir bei der X"~Achse einen festen X"~Wert haben, überspringen wir diesen Teil einfach. Wir haben also nun folgende Gleichung, die es zu lösen gilt: \\
$\left(\begin{array}{c} xLine \\ y_S \end{array}\right) = \left(\begin{array}{c} x_P \\ y_P \end{array}\right) + k * \left(\begin{array}{c} x_R \\ y_R \end{array}\right)$. \\
Dies kann man nun in einem Gleichungssystem folgendermaßen dargestellt werden: \\
$
\begin{array}{ccccccc}
xLine & = & x_P & + & k & * & x_R \\
y_S & = & y_P & + & k & * & y_R
\end{array}
$ \\

\begin{wrapfigure}{R}{0pt}
	\vspace{-15pt}
	\includegraphics{Spiegelung_Quadranten.png}
	\vspace{-15pt}
	\caption{Quadranten bei der Spiegelung}
	\vspace{-15pt}
	\label{img:Quadranten}
\end{wrapfigure}

Wir haben somit die die Y"~Koordinate des Schnittpunktes $Y_S$ und den Skalar k als unbekannte Variablen. Die X"~Koordinate des Schnittpunktes \textit{xLine} wird als Variable an die Funktion übergeben und ist somit bekannt. Die erste Gleichung enthält nur die unbekannte k und kann somit nach k umgestellt werden. Wir erhalten damit die Gleichung: 
$k = \frac{xLine - x_P}{x_R}$.
Da in dieser Gleichung eine Division stattfindet, muss überprüft werden ob der X"~Anteil des Bewegungsvektors $X_R$ ungleich null ist. Dies geschieht im Python Code in Zeile 6 und 7. Direction[0] ist dabei dieses $X_R$. Dies wird so dargestellt, da Vektoren in Python als Array behandelt werden. Vektoren sind somit 1-Dimensionale Array mit in unserem Fall 2 Werten. Der erste Wert, also direction[0] ist der X"~Anteil und der zweite Wert direction[1] ist der Y"~Anteil. Der Richtungsvektor der sich in dem Programm hinter bag.puck.direction verbirgt ist ein Einheitsvekotr, das heißt dass dieser Vektor immer die Länge 1 hat. Deshalb multiplizieren wir zum Richtungsvektor in unserem Code noch die Geschwindigkeit auf. Dadurch erhalten wir einen Richtungsvektor, den der Puck in einer Sekunde beschreitet. Somit kann das errechnete k oder wie wir es in unserem Code bezeichen timeToCrossXLine auch für die benötigte Zeit nutzen, die später für die Angriffsstrategien wichtig ist. Anhand dieses Skalares kann man auch erkennen ob sich der Puck auf den Schnittpunkt zubewegt oder weg bewegt. Denn wenn $k>0$, dann bewegt sich der Puck auf die Schnittachse zu, ansonsten von ihr weg. Mit dem errechneten k, kann man nun auch die 2. Gleichung ausrechnen um die Y"~Koordinate des Schnittpunktes zu erhalten. Dieser errechnete Wert kann aber unter Umständen außerhalb des Spielfeldes liegen und muss deshalb noch an den Banden in das Spielfeld gespiegelt werden. Dies übernimmt die Funktion \textit{mirror\_point\_into\_field}. Diese Funktion nutzt dafür 2 andere Funktionen. Zum ersten die Funktion \textit{check\_for\_out\_of\_field} um den Quadranten zu berechnen in dem sich der Puck befindet. Dabei werden 5 Quadranten unterschieden. Der Quadrant 0 bedeutet, dass sich der Puck innerhalb des Spielfeldes befindet. Quadrant 1 und 2 bedeutet das sich der Puck in X"~Richtung außerhalb des Spielfeldes und somit an den Grenzen der X"~Achsen gespiegelt werden muss. Quadrant 3 und 4 bedeutet das sich der Puck in Y"~Richtung außerhalb des Spielfeldes und somit an den Grenzen der Y"~Achsen gespiegelt werden muss. Im Bild ref{img:Quadranten} auf Seite \pageref{img:Quadranten} sieht man die Anordnung dieser Quadranten. Die unterschiedliche Größe der Quadranten kommt durch die Reihenfolge der Berechnungen zu Stande. Die zweite Funktion die genutzt wird ist die \textit{mirror\_point\_at\_border} Funktion. Dieser Funktion wird der zuvor berechnete Quadrant übergeben und berechnet dann den neuen gespiegelten Punkt. Um den neuen Punkt zu berechnen wird der Abstand des Punktes zur Spielfeldgrenze errechnet und dieser Abstand wird dann von der Spielfeldgrenze subtrahiert. Dies wird solange wiederholt bis der Punkt im Spielfeld liegt.
\begin{lstlisting}[caption= Python-Funktion für Punktspiegelung, label=lst:Punktspiegelung]
def mirror_point_into_field(point):
    bordervalue = check_for_out_of_field(point)
    while bordervalue > 0:
	  point = mirror_point_at_border(point, bordervalue)
	  bordervalue = check_for_out_of_field(point)
    return point
   
def mirror_point_at_border(point, bordervalue):
    yPosition = point[1] 
    xPosition = point[0]
    if bordervalue == border.border.xBy0:
      xPosition = const.CONST.xBorderBy0 - (xPosition - const.CONST.xBorderBy0)
    if bordervalue == border.border.xBy1:
	  xPosition = const.CONST.xBorderBy1 - (xPosition - const.Const.xBorderBy1)
    if bordervalue == border.border.yBy0:
      yPosition = const.CONST.yBorderBy0 -(yPosition - const.CONST.yBorderBy0)
    if bordervalue == border.border.yBy1:
      yPosition = const.CONST.yBorderBy1 -(yPosition - const.CONST.yBorderBy1)
    return (xPosition, yPosition)
   
   
def check_for_out_of_field(point):
  if point[0] < const.CONST.xBorderBy0:
    return border.border.xBy0
  if point[0] > const.CONST.xBorderBy1:
    return border.border.xBy1
  if point[1] < const.CONST.yBorderBy0:
    return border.border.yBy0
  if point[1] > const.CONST.yBorderBy1:
    return border.border.yBy1
  return border.border.infield 
\end{lstlisting}



\subsection{defensive Strategien}
Der einfachste dieser Befehle ist die \enquote{\textit{Fahre die Home-Position an}}. Bei diesem Befehl platziert sich der Roboter direkt mittig vors Tor. In dieser Position ist es nur noch schwer möglich das Tor zu treffen, aber immer noch machbar. 

Der zweite Befehl ist der \textit{Verteidige} Befehl. Bei diesem Befehl bewegt sich der Roboter vor dem Tor auf die Bewegungsbahn des Puckes, damit dieser nicht in das Tor gelangt. Der Python Code für diesen Befehl sieht man in \ref{lst:defensivstrategie} auf Seite \pageref{lst:defensivstrategie}.
\begin{lstlisting}[caption= python-funktion für Defensivstrategie, label=lst:defensivstrategie]
def defend(self, bag):
	koordinates = self.CrossXLine(bag, 0.0)
	robKoordinates = self.transformToRobotkoordinates(koordinates)
	#Position auf unmittelbar vors Tor beschraenken
	ymin = (const.CONST.RobYMax - const.CONST.Torgroesse) / 2.0
	ymax = (const.CONST.RobYMax + const.CONST.Torgroesse) / 2.0
	if robKoordinates[1] < ymin or robKoordinates[1] > ymax:
	  return None
	if abs(self.oldRobotKoordinates[1] - robKoordinates[1]) < const.CONST.minimumMovement:
	  return None
	self.lastMove = self.DEFEND
	#return explizit 0, da CrossXLine die 0 im Bildkoordinatensystem verwendet, die eine andere 0 als im Roboterkoordinatensystem ist
	return (0,robKoordinates[1])
\end{lstlisting}
Dazu wird zuerst der Schnittpunkt mit der Nulllinie der X-Achse berechnet. Diese liegt direkt an der Bande des Spielfeldes. Damit diese auch für den Roboter genutzt werden kann müssen die errechneten Koordinaten noch vom Bildkoordinatensystem in das Roboterkoordinatensystem umgerechnet werden können. Um die Verteidigungsbewegung auch wirklich auszuführen, müssen noch 2 zusätzliche Kriterien erfüllt werden. Die erste Kriterium ist, das der Puck sich auch wirklich auf das Tor zu bewegt und nicht irgendwo neben dem Tor gegen die Bande prallt. Dies wird im Code in den Zeilen 5"~8 entschieden indem zuerst die Torbegrenzungen  \textit{ymin} und \textit{ymax} berechnet werden. sollte der errechnete Schnittpunkt außerhalb liegen, wird die Funktion abgebrochen. Sollte sich der Schläger bereits in einem gewissen Toleranzbereich vom errechneten Punkt befinden, soll sich der Roboter auch nicht erneut bewegen, da dieser dann für eine kurze Zeit nicht mehr reagieren kann. Dieser Toleranzbereich ist mit der Konstante minimumMovement festgelegt und beträgt 25 mm. Sollten diese Fälle nicht eintreffen, merkt sich das Programm das es zuletzt diese Funktion ausgeführt hat und gibt die Koordinaten zu denen sich der Roboter bewegen soll zurück. Dabei wird für die X"~Koordinate explizit 0 verwendet, da die X"~Koordinate von der CrossXLine Funktion im Bildkoordinatensystem 0 ist, was nicht ganz exakt 0 im Roboterkoordinatensystem ist. Ansonsten gäbe es eine Verschiebung von etwa 3mm, die immer recht merkwürdig aussah wenn sie auftrat.


\subsection{offensive Strategien}
Es gibt 2 offensive Strategien. Die Strategie \textit{attack1} ist dabei die Vorbereitung auf den Angriff und \textit{attack2} ist Ausführung des Angriffes. Bei der Vorbereitung zum Angriff bewegt sich der Puck auf der Nulllinie der X"~Achse , so dass dieser dann nur noch eine Vorwärtsbewegung für den Angriff machen muss. Der Angriff ist dann quasi die Vorwärtsbewegung um den Puck zurückzuschlagen.
Den Sourcecode zu beiden Funktionen sieht man im listing \ref{lst:Offensivstrategien} auf Seite \pageref{lst:Offensivstrategien}.
Der Funktion \textit{attack1} werden direkt die Koordinaten des errechneten Schnittpunktes übergeben. Es wird nur überprüft ob diese Koordinaten zu nah an den Außenbanden liegen um zu verhindern, dass der Roboter den Puck zwischen Bande und Schläger einquetscht. Sollte dies nicht der Fall sein, merkt sich das Programm das \textit{attack1} zuletzt ausgeführt wurde und gibt die Koordinaten zu denen sich der Roboter bewegen soll zurück.
Bei \textit{attack2} muss als erstes die aktuelle Position des Roboters vom Roboterkoordinatensystem ins Bildkoordinatensystem umgerechnet werden, da diese für die Schnittpunktberechnung benötigt wird. Für die Schnittpunktberechnung werden bei dieser Funktion je nach Situation unterschiedliche Schnittachsen verwendet. Sollte sich der Puck in einem spitzen Winkel von etwa 18$\circ$ der Y"~Achse nähern, wird der Schnittpunkt zur X"~Achse etwa 20cm vor dem Tor berechnet. Sollte dieser Fall eintreffen, wird noch zusätzlich überprüft ob der Schlag nicht zu schräg wird, da dann unsere Berechnung zur benötigten Zeit des Schlages nicht mehr stimmt und um wieder zu verhindern. dass der Puck zwischen Bande und Shläger eingequetscht wird. Dieser Fall sollte zwar nicht eintreffen, da dieser vorher bereits abgefangen wird, ist aber aus Sicherheitsgründen hier immer noch enthalten. Sollte der Winkel zur Y"~Achse größer sein, wird der Schnittpunkt mit der Y"~Achse berechnet, wobei dann der Y"~Wert der aktuellen Roboterposition verwendet wird. Dies wird so gelöst, da die Berechnungen mit der Y"~Achse als Schnittachse genauer sind. Allerdings erhält man bei Spitzen Winkeln zur Y"~Achse häufig nicht nutzbare Werte dadurch. Sobald man den Schnittpunkt hat, wird noch überprüft ob dieser vom Roboter überhaupt erreicht werden kann. Dies sollte nur auftreten wenn der Puck während einer Pendelbewegung angegriffen wird und der Puck zu weit vom Roboter weg ist. Dies wird im Kapitel \ref{sec:Strategieentscheidung} auf Seite \pageref{sec:Strategieentscheidung} etwas genauer erklärt. Wenn der Roboter den errechneten Schnittpunkt in seiner Bewegungszeit mit Abweichung einer Framzeit erreichen kann, wird der Angriffsschlag ausgeführt, ansonsten wird gewartet bis er den Schnittpunkt in der errechneten Zeit erreichen kann.
\begin{lstlisting}[caption= python-funktion für Offensivstrategien, label=lst:Offensivstrategien]
def attack1(self, robKoordinates):
	if robKoordinates[1] < const.CONST.durchmesserPuck:
	  return None
	if robKoordinates[1] > const.CONST.RobYMax - const.CONST.durchmesserPuck:
	  return None
	self.lastMove = self.ANGRIFF1
	return (0, robKoordinates[1])
    
def attack2(self, bag):
	#alte Roboterkoordinaten ins Bildsystem umrechnen
	y = (self.oldRobotKoordinates[1] + const.CONST.durchmesserSchlaeger / 2.0) / (const.CONST.tableWidth +  const.CONST.durchmesserSchlaeger)
	# sollte der Puck sich dem Schlaeger in einem Winkel kleiner 18 Grad naehern,
	# wird der schnittpunkt mit der x - Achse verwendet ansonsten der Schnittpunkt mit der y-Achse
	if bag.puck.direction[0] < -0.95:
	  koordinates = self.CrossXLine(bag, 0.18)
	  # Wenn der Schlag zu schraeg wird, Angriff abbrechen
	  if abs(koordinates[1] - y) > 0.2:
	    print("Angriff 2 abgebrochen")
	    return None
	else:
	  koordinates = self.CrossYLine(bag, y)	
	robKoordinates = self.transformToRobotkoordinates(koordinates)
	if not self.roboter.robCanReachPoint(robKoordinates):
	  return None
	if abs(self.calculateTimeToXPoint(robKoordinates) - koordinates[2]) < 1.0 / const.CONST.FPS:
	  self.lastMove = self.ANGRIFF2
	  return robKoordinates
	return None
\end{lstlisting}

\subsection{Strategieentscheidung}
\label{sec:Strategieentscheidung}
Für die Auswahl der richtigen Stratgie haben wir einen komplexen Entscheidungsbaum entworfen, der auf verschiedene Parameter zurückgreift. Zu diesen Parametern zählen die aktuelle Position, die Bewegungsrichtung und Bewegungsgeschwindigkeit des Puckes, die zuletzt befahrene Position des Roboters und die zuletzt ausgeführte Aktion des Roboters. Im Bild \ref{img:Entscheidungsbaum Strategieauswahl} auf Seite \pageref{img:Entscheidungsbaum Strategieauswahl} sehen sie das Flussdiagramm dieses Einscheidungsbaumes. Wenn der Roboter als letzte Bewegung einen Angriff ausgeführt hat um den Puck zurück zu schlagen, steht in den meisten Fällen das Tor komplett frei. Um einen Konter entgegenzukommen, bewegt sich der Roboter anschließend sofort vors Tor. Denn so wird der Weg zum Verteidigen erheblich verkürzt. Wenn sich der Puck in der gegnerischen Hälfte befindet, werden nur defensive Strategien in Betracht gezogen, da sich der Puck bei offensiven Strategien vom Tor entfernt, aber der Gegner die Bahn des Puckes immer noch beeinflussen kann. Sollte sich der Puck in der gegnerischen Hälfte vom Roboter wegbewegen sollte der Roboter zurück in die Homeposition gehen um sich alle Möglichkeiten offen zu lassen, da der Puck vom Gegenspieler auf jeden Fall noch beeinflusst wird. Bewegt sich der Puck statdessen schon auf den Roboter zu soll dieser die \textit{Defend} Funktion aufrufen um einen möglichen Angriff bereits entgegenzuwirken.

Beim nächsten Schritt wird ermittelt ob der Puck auf der Spielfeldseite des Roboters pendelt. Als Pendeln haben wir festgelegt wenn der Roboter in einem Winkel kleiner 20$\circ$ entlang der Y"~Achse sich bewegt. Dies ist der Fall, wenn der Betrag des normalisierten Bewegungsvektors in X"~Richtung kleiner als 0,35 ist, denn $\arccos 0,35 \approx 70\circ$ in X"~Richtung, also etwa 20$\circ$ in Y"~Richtung. Sollte sich der Puck in so einer Pendelbewegung befinden fährt der Roboter mittig vors Tor oder wenn dies schon geschehen ist, macht der Roboter einen Angriffsschlag. Der Grund wieso der Roboter erst mittig vors Tor fährt ist folgender. Mit voll ausgestreckten Arm macht der Roboter eine Kreisförmige Bewegung, dadurch kann er unterschiedlich weit in das Spielfeld hineinreichen. Am Rand des Spielfeldes erreicht dieser eine Maximalreichweite von etwa 26cm, wohingegen er in der Mitte etwa 38cm schafft. Aber diese 38 cm sind trotzdem nur etwa 55\% seiner eigenen Spielfeldhälfte, wodurch dieser nicht immer den Puck erreichen kann und der Spieler warten muss, bis der Puck dann irgendwann mal auf seine eigene Hälfte zurück pendelt.

Sollten diese Entshceidungen nicht die richtigen gewesen sein, wird nun der Schnittpunkt mit einer X"~Achse, die sich etwa 20cm vor dem Tor befindet berechnet. Wenn die letzte Bewegung eine Vorbereitung auf den Angriff war, also \textit{attack1} ausgeführt wurde, wird überprüft ob die zuletzt berechnete Position nicht weiter als 2,5cm von der aktuell berechneten Position entfernt liegt. Diese 2,5cm sind die selbe Konstante minimumMovement, wie sie auch im Defendalghorithmus auf Seite \pageref{lst:defensivstrategie} verwendet wird. Sollte dies der Fall sein, wird die Funktion \textit{attack2} ausgeführt. Sollte als letztes nicht \textit{attack1} ausgeführt worden sein oder die neu berechnete Position weicht zu sehr von der alten ab, wird überprüft ob der Roboter mit eine Bewegung in Y"~Richtung und einer anschließenden Bewegung in X"~Richtung den Puck erreichen kann. Sollte die benötigte Zeit nicht ausreichen, also der Puck kommt vor dem Schläger an, wird die \textit{defend} Funktion ausgeführt. Sollte der Roboter aber genug Zeit haben, wird der Angriffsschlag mit der \textit{attack1} Funktion vorbereitet.

\begin{figure}[htbp]
	\includegraphics[width=\textwidth]{Stratigy_Decision1.png}
	\caption{Entscheidungsbaum für die Strategieauswahl}
	\label{img:Entscheidungsbaum Strategieauswahl}
\end{figure}