%!TEX root = ../dokumentation.tex

\chapter{Implementierung der Spielstrategie}
\section{Erweiterung des Bilderkennungsprogramms um Kommunikationsmodul}
Die Kommunikation zwischen PC und Roboter erfolgt wie in Kapitel \ref{cha:Kommunikation zwischen Bilderkennung und Roboter} auf Seite \pageref{cha:Kommunikation zwischen Bilderkennung und Roboter} mithilfe von Sockets. Der PC öffnet einen Serversocket und der Roboter einen Clientsocket. Die Socketkommunikation funktioniert nach dem TCP/IP Verfahren. Man weiß also immer ob die Kommunikation zu Stande kam.
Ursprünglich hatten wir für jede Übertragung einen neuen Socket erstellt, die Daten übermittelt und anschließend den Socket wieder geschlossen. Dies haben wir so praktiziert da in der Python Dokumentation geschrieben stand, das Sockets normalerweise nur für eine Übertratung oder eine kleine Folge von Übertragungen genutzt wird und anschließend wieder geschlossen wird.
\quote{When the connect completes, the socket s can be used to send in a request for the text of the page. The same socket will read the reply, and then be destroyed. That’s right, destroyed. Client sockets are normally only used for one exchange (or a small set of sequential exchanges).\footnote{biber referenz für \url{https://docs.python.org/2/howto/sockets.html}}}
Da auch der Socket auf der Serverseite geschlossen wurde, konnte bei einem erneuten Kommunikationsversuches des Clients keine Verbindung zum Serversocket des Roboters hergestellt werden. Dadurch wussten wir auch automatisch, dass der Roboter sich noch bewegt und keine neuen Befehle entgegen nehmen kann. Wir hatten für die Sockets eine timeoutzeit von 1/100s\footnote{Bruch?} eingestellt. Somit hat ein Kommunikationsversuch mit dem Roboter maximal 1/50s benötigt. Einmal  1/100s für die Verbindung aufbauen und einmal 1/100s für die Daten senden. Da wir mit der angebauten 30 FPS Kamera nur alle 1/30s neue Bilder erhielten mit denen man neu rechnen muss, war diese 1/50s Maximalzeit auch ausreichend. Es hat sich aber herausgestellt, das anscheinend durch das Socket öffnen und schließen eine viel größere Zeit benötigt wird. Denn zwischen dem senden eines Befehls und dem erneuten senden eines Befehls vergingen mindestens eine halbe Sekunde, selbst wenn sich der Roboter gar nicht bewegen muss. Hinzu kam noch, dass das Schließen des Sockets auf Serverseite länger benötigt als auf Clientseite. Die Zeit die zum Schließen des Serversockets benötigt wurde, hat wahrscheinlich auch diese halbe Sekunde Latenzzeit verursacht. Es entstand aber auch noch ein anderer Nebeneffekt dadurch. Denn der Clientsocket hat in dieser Zeit immer noch eine Verbindung mit dem Serversocket erstellen können und hat somit auch noch Daten geschickt. Diese Daten kamen aber nicht mehr beim Serversocket an, sondern wurden irgendwo zwischen gebuffert. Beim nächsten öffnen des Serversockets wurden dann diese Daten sofort empfangen und verarbeitet. Durch diesen Buffer entstanden immer Ausreißer des Roboters, die wir uns lange Zeit nicht erklären konnten. Wir haben dieses Problem dann erst mitbekommen, nachdem wir ein paar Tests durchgeführt haben um die Geschwindigkeit des Roboters festzustellen. Das Programm für die Test hat dann häufig bis zu 3 Werte hintereinander geschickt, bevor es gewartet hat, das der Roboter einen neuen Serversocket geöffnet hat. Wir führten darauf hin einen Two-Way-Handshake ein. Ursprünglich hatten wir dann solange gewartet bis der Roboter sein OK geschickt hat. Dabei hatten wir nur ein nicht beachtet und zwar dass das Programm sequentiell abläuft und für die Wartezeit wie eingefroren ist. Das heißt wir haben dann auch nur alle halbe Sekunde das neue Bild von der Kamera ausgewertet. Dadurch konnte das ganze Programm nicht mehr ordentlich reagieren, da keine vernünftigen Puckbewegungen mehr errechnet werden konnten. Beim zweiten Versuch, wurde pro Programmzyklus nur einmal überprüft ob der Roboter sein OK gesendet hat. Wenn dieses OK nicht kam wurde auf das neue Bild gewartet und dann erneut abgefragt bis der Roboter sein OK gesendet hat. Dadurch konnten wir zwar die Aussreißer stark reduzieren, aber es gab immer noch die hohe Latenzzeit von mindestens einer halben Sekunde. Am Ende haben wir uns dann gegen die Empfehlung der Python Dokumentation entschieden und nur am Amfang des Programmstartes einen Socket zu öffnen und diesen über die komplette Programmlaufzeit offen zu lassen. Wir konnten auch bei längeren Laufzeiten von einer halben Stunde und mehr keine Irregularitäten feststellen, weshalb wir entschieden haben, dies dann so zu lassen. Der einzige Nachteil war, dass wir die Sockets auf diese Art und Weise nicht ordentlich schließen konnten, denn es gibt in Python keinen Deconstructor, wie man ihn aus anderen Objektorientierten Programmiersprachen kennt. Deshalb muss man nach Abbruch des Programms 1-2 Minuten warten bis das Betriebssystem den Socket von alleine wieder schließt. Leider kann man ohne eine Referenz auf den Socket diesen nicht manuell schließen. Und da wir nicht jedesmal den Programmcode umschreiben wollten um einen neuen Port einzutragen, mussten wir zwischen den Tests immer ein weilchen warten.
%Die Kommunikation zwischen PC und Roboter erfolgt mithilfe von Sockets. Der Roboter öffnet dafür einen Serversocket und horcht auf einen bestimmten Port. Der PC erzeugt einen Clientsocket und verbindet sich mit der IP-Adresse des Roboters und dem gewählten Port. Die Socketkommunikation funktioniert nach dem TCP/IP Verfahren. Man weiß also immer ob die Kommunikation zu Stande kam. Nachdem die Kommunikation zu stande kam werden die Daten nach dem UDP-Verfahren gesendet ohne zu überprüfen ob der Roboter die Daten erhalten hat. Ursprünglich hatten wir eine Art Two-Way-Handshake implementiert, so das der Roboter nach dem Erhalt der Daten eine kurze Rückmeldung sendete. Dies hat aber zu lange gedauert wodurch das komplette Programm gelaggt hat.

\section{Implementierung von Spielstrategien}
\subsection{Defensive Spielstrategie}
Bei der Defensiven Spielstrategie wird der Schläger nur auf einer geraden Linie parallel zum Tor bewegt. Bei dieser Strategie kann man grundsätzlich von 2 Situationen ausgehen. Die erste ist, der Puck bewegt sich auf den Roboter zu. Der Roboter versucht den Puck abzuwehren, erstmal ungeachtet ob der Puck sich überhaupt aufs Tor zu bewegt oder daran vorbeigehen würde. Bei der zweiten Situation bewegt sich der Puck vom Roboter weg. Dabei sollte sich der Puck zwischen dem Tor des Roboters und dem Puck positionieren und dem nächsten Angriff des Spielers zuvorzukommen.

Bei einer erweiterten Defensivstrategie könnte z.B. zusätzlich überprüft werden ob der Puck überhaupt das Tor trifft oder in die Nähe des Tores kommt um unnötige Bewegungen zu vermeiden.

\subsection{offensive Spielstrategie}
Bei der Offensiven Strategie versucht der Roboter immer den Puck sofort zurückzuschlagen ohne an eine Verteidigung zu denken, frei nach dem Motto “Angriff ist die beste Verteidigung”. Dabei sollte angefangen werden den Puck nur zurückzuschlagen ungeachtet der Richtung. Sollte diese Taktik funktionieren, kann man dann ergänzen, dem Puck beim zurückschlagen eine bestimme Richtung zu geben, damit der Roboter gezielter das gegnerische Tor trifft.

Später kann diese Strategie so erweitert werden, dass sich der Roboter nicht direkt auf den Puck zu bewegt, sondern sich vorher noch positioniert um eine bessere Angriffsposition zu haben.
\subsection{Defensive Spielstrategie mit offensiven Ansätzen}
Es wird weiterhin die selbe Taktik wie bei der rein defensiven Taktik genutzt. Zusätzlich wird ergänzt, das nach dem Blocken des Puckes, dieser mit der offensiven Strategie zurückgeschlagen wird.

\subsection{ausbalancierte Spielstrategie}
Bei der ausbalancierten Spielstrategie wird selbstständig vom Roboter entschieden, ob die Defensive oder die offensive Strategie verwendet wird. Bei der defensiven Strategie sollte die Verteidigungslinie auf einen Halbkreis um das Tor reduziert werden um unnötige Verteidigungsaktionen zu vermeiden.



\section{Spielstrategie entscheiden}

